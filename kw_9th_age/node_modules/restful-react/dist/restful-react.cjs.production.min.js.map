{"version":3,"file":"restful-react.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/Context.tsx","../src/util/composeUrl.ts","../src/util/processResponse.ts","../src/Get.tsx","../src/util/resolveData.ts","../src/Poll.tsx","../src/Mutate.tsx","../src/util/useDeepCompareEffect.ts","../src/useAbort.ts","../src/useGet.tsx","../src/useMutate.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import noop from \"lodash/noop\";\nimport * as React from \"react\";\nimport { IStringifyOptions } from \"qs\";\nimport { ResolveFunction } from \"./Get\";\n\nexport interface RestfulReactProviderProps<TData = any> {\n  /** The backend URL where the RESTful resources live. */\n  base: string;\n  /**\n   * The path that gets accumulated from each level of nesting\n   * taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Options passed to the fetch request.\n   */\n  requestOptions?: (() => Partial<RequestInit> | Promise<Partial<RequestInit>>) | Partial<RequestInit>;\n  /**\n   * Trigger on each error.\n   * For `Get` and `Mutation` calls, you can also call `retry` to retry the exact same request.\n   * Please note that it's quite hard to retrieve the response data after a retry mutation in this case.\n   * Depending of your case, it can be easier to add a `localErrorOnly` on your `Mutate` component\n   * to deal with your retry locally instead of in the provider scope.\n   */\n  onError?: (\n    err: {\n      message: string;\n      data: TData | string;\n      status?: number;\n    },\n    retry: () => Promise<TData | null>,\n    response?: Response,\n  ) => void;\n  /**\n   * Trigger on each request\n   */\n  onRequest?: (req: Request) => void;\n  /**\n   * Trigger on each response\n   */\n  onResponse?: (res: Response) => void;\n  /**\n   * Any global level query params?\n   * **Warning:** it's probably not a good idea to put API keys here. Consider headers instead.\n   */\n  queryParams?: { [key: string]: any };\n  /**\n   * Query parameter stringify options applied for each request.\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n}\n\nexport const Context = React.createContext<Required<RestfulReactProviderProps>>({\n  base: \"\",\n  parentPath: \"\",\n  resolve: (data: any) => data,\n  requestOptions: {},\n  onError: noop,\n  onRequest: noop,\n  onResponse: noop,\n  queryParams: {},\n  queryParamStringifyOptions: {},\n});\n\nexport interface InjectedProps {\n  onError: RestfulReactProviderProps[\"onError\"];\n  onRequest: RestfulReactProviderProps[\"onRequest\"];\n  onResponse: RestfulReactProviderProps[\"onResponse\"];\n}\n\nexport default class RestfulReactProvider<T> extends React.Component<RestfulReactProviderProps<T>> {\n  public static displayName = \"RestfulProviderContext\";\n\n  public render() {\n    const { children, ...value } = this.props;\n    return (\n      <Context.Provider\n        value={{\n          onError: noop,\n          onRequest: noop,\n          onResponse: noop,\n          resolve: (data: any) => data,\n          requestOptions: {},\n          parentPath: \"\",\n          queryParams: value.queryParams || {},\n          queryParamStringifyOptions: value.queryParamStringifyOptions || {},\n          ...value,\n        }}\n      >\n        {children}\n      </Context.Provider>\n    );\n  }\n}\n\nexport const RestfulReactConsumer = Context.Consumer;\n","import url from \"url\";\n\nexport const composeUrl = (base: string = \"\", parentPath: string = \"\", path: string = \"\"): string => {\n  const composedPath = composePath(parentPath, path);\n  /* If the base is empty, preceding slash will be trimmed during composition */\n  if (base === \"\" && composedPath.startsWith(\"/\")) {\n    return composedPath;\n  }\n\n  /* If the base contains a trailing slash, it will be trimmed during composition */\n  return base!.endsWith(\"/\") ? `${base!.slice(0, -1)}${composedPath}` : `${base}${composedPath}`;\n};\n\n/**\n * If the path starts with slash, it is considered as absolute url.\n * If not, it is considered as relative url.\n * For example,\n * parentPath = \"/someBasePath\" and path = \"/absolute\" resolves to \"/absolute\"\n * whereas,\n * parentPath = \"/someBasePath\" and path = \"relative\" resolves to \"/someBasePath/relative\"\n */\nexport const composePath = (parentPath: string = \"\", path: string = \"\"): string => {\n  if (path.startsWith(\"/\") && path.length > 1) {\n    return url.resolve(parentPath, path);\n  } else if (path !== \"\" && path !== \"/\") {\n    return `${parentPath}/${path}`;\n  } else {\n    return parentPath;\n  }\n};\n","export const processResponse = async (response: Response) => {\n  if (response.status === 204) {\n    return { data: undefined, responseError: false };\n  }\n  if ((response.headers.get(\"content-type\") || \"\").includes(\"application/json\")) {\n    try {\n      return {\n        data: await response.json(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: e.message,\n        responseError: true,\n      };\n    }\n  } else if (\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/plain\") ||\n    (response.headers.get(\"content-type\") || \"\").includes(\"text/html\")\n  ) {\n    try {\n      return {\n        data: await response.text(),\n        responseError: false,\n      };\n    } catch (e) {\n      return {\n        data: e.message,\n        responseError: true,\n      };\n    }\n  } else {\n    return {\n      data: response,\n      responseError: false,\n    };\n  }\n};\n","import { DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport isEqual from \"lodash/isEqual\";\nimport * as qs from \"qs\";\nimport * as React from \"react\";\n\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\nimport { resolveData } from \"./util/resolveData\";\n\n/**\n * A function that resolves returned data from\n * a fetch call.\n */\nexport type ResolveFunction<TData> = (data: any) => TData;\n\nexport interface GetDataError<TError> {\n  message: string;\n  data: TError | string;\n  status?: number;\n}\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport type GetMethod<TData> = () => Promise<TData | null>;\n\n/**\n * An interface of actions that can be performed\n * within Get\n */\nexport interface Actions<TData> {\n  /** Refetches the same path */\n  refetch: GetMethod<TData>;\n}\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The entire response object passed back from the request. */\n  response: Response | null;\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Get /> component.\n */\nexport interface GetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * A function that recieves the returned, resolved\n   * data.\n   *\n   * @param data - data returned from the request.\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions<TData>, meta: Meta) => React.ReactNode;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: ResolveFunction<TData>;\n  /**\n   * Should we wait until we have data before rendering?\n   * This is useful in cases where data is available too quickly\n   * to display a spinner or some type of loading state.\n   */\n  wait?: boolean;\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\n/**\n * State for the <Get /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface GetState<TData, TError> {\n  data: TData | null;\n  response: Response | null;\n  error: GetDataError<TError> | null;\n  loading: boolean;\n}\n\n/**\n * The <Get /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessGet<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<GetState<TData, TError>>\n> {\n  constructor(props: GetProps<TData, TError, TQueryParams, TPathParams> & InjectedProps) {\n    super(props);\n\n    if (typeof props.debounce === \"object\") {\n      this.fetch = debounce(this.fetch, props.debounce.wait, props.debounce.options);\n    } else if (typeof props.debounce === \"number\") {\n      this.fetch = debounce(this.fetch, props.debounce);\n    } else if (props.debounce) {\n      this.fetch = debounce(this.fetch);\n    }\n  }\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public readonly state: Readonly<GetState<TData, TError>> = {\n    data: null, // Means we don't _yet_ have data.\n    response: null,\n    loading: !this.props.lazy,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    resolve: (unresolvedData: any) => unresolvedData,\n    queryParams: {},\n  };\n\n  public componentDidMount() {\n    if (!this.props.lazy) {\n      this.fetch();\n    }\n  }\n\n  public componentDidUpdate(prevProps: GetProps<TData, TError, TQueryParams, TPathParams>) {\n    const { base, parentPath, path, resolve, queryParams, requestOptions } = prevProps;\n    if (\n      base !== this.props.base ||\n      parentPath !== this.props.parentPath ||\n      path !== this.props.path ||\n      !isEqual(queryParams, this.props.queryParams) ||\n      // both `resolve` props need to _exist_ first, and then be equivalent.\n      (resolve && this.props.resolve && resolve.toString() !== this.props.resolve.toString()) ||\n      (requestOptions &&\n        this.props.requestOptions &&\n        requestOptions.toString() !== this.props.requestOptions.toString())\n    ) {\n      if (!this.props.lazy) {\n        this.fetch();\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public getRequestOptions = async (\n    extraOptions?: Partial<RequestInit>,\n    extraHeaders?: boolean | { [key: string]: string },\n  ) => {\n    const { requestOptions } = this.props;\n\n    if (typeof requestOptions === \"function\") {\n      const options = (await requestOptions()) || {};\n      return {\n        ...extraOptions,\n        ...options,\n        headers: new Headers({\n          ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n          ...(extraOptions || {}).headers,\n          ...options.headers,\n        }),\n      };\n    }\n\n    return {\n      ...extraOptions,\n      ...requestOptions,\n      headers: new Headers({\n        ...(typeof extraHeaders !== \"boolean\" ? extraHeaders : {}),\n        ...(extraOptions || {}).headers,\n        ...(requestOptions || {}).headers,\n      }),\n    };\n  };\n\n  public fetch = async (requestPath?: string, thisRequestOptions?: RequestInit) => {\n    const { base, __internal_hasExplicitBase, parentPath, path, resolve, onError, onRequest, onResponse } = this.props;\n\n    if (this.state.error || !this.state.loading) {\n      this.setState(() => ({ error: null, loading: true }));\n    }\n\n    const makeRequestPath = () => {\n      let url: string;\n      if (__internal_hasExplicitBase) {\n        url = composeUrl(base!, \"\", path || \"\");\n      } else {\n        url = composeUrl(base!, parentPath!, requestPath || path || \"\");\n      }\n\n      // We use ! because it's in defaultProps\n      if (Object.keys(this.props.queryParams!).length) {\n        url += `?${qs.stringify(this.props.queryParams)}`;\n      }\n      return url;\n    };\n\n    const request = new Request(makeRequestPath(), await this.getRequestOptions(thisRequestOptions));\n    if (onRequest) onRequest(request);\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      // avoid state updates when component has been unmounted\n      if (this.signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n\n        this.setState({\n          loading: false,\n          error,\n        });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => this.fetch(requestPath, thisRequestOptions), response);\n        }\n\n        return null;\n      }\n\n      const resolved = await resolveData<TData, TError>({ data, resolve });\n\n      this.setState({ loading: false, data: resolved.data, error: resolved.error });\n      return data;\n    } catch (e) {\n      // avoid state updates when component has been unmounted\n      // and when fetch/processResponse threw an error\n      if (this.signal.aborted) {\n        return;\n      }\n\n      this.setState({\n        loading: false,\n        error: {\n          message: `Failed to fetch: ${e.message}`,\n          data: e,\n        },\n      });\n    }\n  };\n\n  public render() {\n    const { children, wait, path, base, parentPath } = this.props;\n    const { data, error, loading, response } = this.state;\n\n    if (wait && data === null && !error) {\n      return <></>; // Show nothing until we have data.\n    }\n\n    return children(\n      data,\n      { loading, error },\n      { refetch: this.fetch },\n      { response, absolutePath: composeUrl(base!, parentPath!, path) },\n    );\n  }\n}\n\n/**\n * The <Get /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Get<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: GetProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path)}>\n          <ContextlessGet\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Get;\n","import { GetDataError, ResolveFunction } from \"../types\";\n\nexport const resolveData = async <TData, TError>({\n  data,\n  resolve,\n}: {\n  data: any;\n  resolve?: ResolveFunction<TData>;\n}): Promise<{ data: TData | null; error: GetDataError<TError> | null }> => {\n  let resolvedData: TData | null = null;\n  let resolveError: GetDataError<TError> | null = null;\n  try {\n    if (resolve) {\n      const resolvedDataOrPromise: TData | Promise<TData> = resolve(data);\n      resolvedData = (resolvedDataOrPromise as { then?: any }).then\n        ? ((await resolvedDataOrPromise) as TData)\n        : (resolvedDataOrPromise as TData);\n    } else {\n      resolvedData = data;\n    }\n  } catch (err) {\n    resolvedData = null;\n    resolveError = {\n      message: \"RESOLVE_ERROR\",\n      data: JSON.stringify(err),\n    };\n  }\n  return {\n    data: resolvedData,\n    error: resolveError,\n  };\n};\n","import merge from \"lodash/merge\";\nimport * as qs from \"qs\";\nimport * as React from \"react\";\nimport equal from \"react-fast-compare\";\n\nimport { InjectedProps, RestfulReactConsumer } from \"./Context\";\nimport { GetProps, GetState, Meta as GetComponentMeta } from \"./Get\";\nimport { composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\n\n/**\n * Meta information returned from the poll.\n */\ninterface Meta extends GetComponentMeta {\n  /**\n   * The entire response object.\n   */\n  response: Response | null;\n}\n\n/**\n * States of the current poll\n */\ninterface States<TData, TError> {\n  /**\n   * Is the component currently polling?\n   */\n  polling: PollState<TData, TError>[\"polling\"];\n  /**\n   * Is the initial request loading?\n   */\n  loading: PollState<TData, TError>[\"loading\"];\n  /**\n   * Has the poll concluded?\n   */\n  finished: PollState<TData, TError>[\"finished\"];\n  /**\n   * Is there an error? What is it?\n   */\n  error: PollState<TData, TError>[\"error\"];\n}\n\n/**\n * Actions that can be executed within the\n * component.\n */\ninterface Actions {\n  start: () => void;\n  stop: () => void;\n}\n\n/**\n * Props that can control the Poll component.\n */\nexport interface PollProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * What path are we polling on?\n   */\n  path: GetProps<TData, TError, TQueryParams, TPathParams>[\"path\"];\n  /**\n   * A function that gets polled data, the current\n   * states, meta information, and various actions\n   * that can be executed at the poll-level.\n   */\n  children: (data: TData | null, states: States<TData, TError>, actions: Actions, meta: Meta) => React.ReactNode;\n  /**\n   * How long do we wait between repeating a request?\n   * Value in milliseconds.\n   *\n   * Defaults to 1000.\n   */\n  interval?: number;\n  /**\n   * How long should a request stay open?\n   * Value in seconds.\n   *\n   * Defaults to 60.\n   */\n  wait?: number;\n  /**\n   * A stop condition for the poll that expects\n   * a boolean.\n   *\n   * @param data - The data returned from the poll.\n   * @param response - The full response object. This could be useful in order to stop polling when !response.ok, for example.\n   */\n  until?: (data: TData | null, response: Response | null) => boolean;\n  /**\n   * Are we going to wait to start the poll?\n   * Use this with { start, stop } actions.\n   */\n  lazy?: GetProps<TData, TError, TQueryParams, TPathParams>[\"lazy\"];\n  /**\n   * Should the data be transformed in any way?\n   */\n  resolve?: (data: any, prevData: TData | null) => TData;\n  /**\n   * We can request foreign URLs with this prop.\n   */\n  base?: GetProps<TData, TError, TQueryParams, TPathParams>[\"base\"];\n  /**\n   * Any options to be passed to this request.\n   */\n  requestOptions?: GetProps<TData, TError, TQueryParams, TPathParams>[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n}\n\n/**\n * The state of the Poll component. This should contain\n * implementation details not necessarily exposed to\n * consumers.\n */\nexport interface PollState<TData, TError> {\n  /**\n   * Are we currently polling?\n   */\n  polling: boolean;\n  /**\n   * Have we finished polling?\n   */\n  finished: boolean;\n  /**\n   * What was the last response?\n   */\n  lastResponse: Response | null;\n  /**\n   * What data are we holding in here?\n   */\n  data: GetState<TData, TError>[\"data\"];\n  /**\n   * What data did we had before?\n   */\n  previousData: GetState<TData, TError>[\"data\"];\n  /**\n   * Are we loading?\n   */\n  loading: GetState<TData, TError>[\"loading\"];\n  /**\n   * Do we currently have an error?\n   */\n  error: GetState<TData, TError>[\"error\"];\n  /**\n   * Index of the last polled response.\n   */\n  lastPollIndex?: string;\n}\n\n/**\n * The <Poll /> component without context.\n */\nclass ContextlessPoll<TData, TError, TQueryParams, TPathParams = unknown> extends React.Component<\n  PollProps<TData, TError, TQueryParams, TPathParams> & InjectedProps,\n  Readonly<PollState<TData, TError>>\n> {\n  public readonly state: Readonly<PollState<TData, TError>> = {\n    data: null,\n    previousData: null,\n    loading: !this.props.lazy,\n    lastResponse: null,\n    polling: !this.props.lazy,\n    finished: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    interval: 1000,\n    wait: 60,\n    base: \"\",\n    resolve: (data: any) => data,\n    queryParams: {},\n  };\n\n  private keepPolling = !this.props.lazy;\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  private isModified = (response: Response, nextData: TData) => {\n    if (response.status === 304) {\n      return false;\n    }\n    if (equal(this.state.data, nextData)) {\n      return false;\n    }\n    return true;\n  };\n\n  private getRequestOptions = () =>\n    typeof this.props.requestOptions === \"function\" ? this.props.requestOptions() : this.props.requestOptions || {};\n\n  // 304 is not a OK status code but is green in Chrome 🤦🏾‍♂️\n  private isResponseOk = (response: Response) => response.ok || response.status === 304;\n\n  /**\n   * This thing does the actual poll.\n   */\n  public cycle = async () => {\n    // Have we stopped?\n    if (!this.keepPolling) {\n      return; // stop.\n    }\n\n    // Should we stop?\n    if (this.props.until && this.props.until(this.state.data, this.state.lastResponse)) {\n      await this.stop(); // stop.\n      return;\n    }\n\n    // If we should keep going,\n    const { base, path, interval, wait, onError, onRequest, onResponse } = this.props;\n    const { lastPollIndex } = this.state;\n    const requestOptions = await this.getRequestOptions();\n\n    let url = composeUrl(base!, \"\", path);\n\n    // We use a ! because it's in defaultProps\n    if (Object.keys(this.props.queryParams!).length) {\n      url += `?${qs.stringify(this.props.queryParams)}`;\n    }\n\n    const request = new Request(url, {\n      ...requestOptions,\n      headers: {\n        Prefer: `wait=${wait}s;${lastPollIndex ? `index=${lastPollIndex}` : \"\"}`,\n        ...requestOptions.headers,\n      },\n    });\n    if (onRequest) onRequest(request);\n\n    try {\n      const response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n      const { data, responseError } = await processResponse(response);\n\n      if (!this.keepPolling || this.signal.aborted) {\n        // Early return if we have stopped polling or component was unmounted\n        // to avoid memory leaks\n        return;\n      }\n\n      if (!this.isResponseOk(response) || responseError) {\n        const error = {\n          message: `Failed to poll: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n          data,\n          status: response.status,\n        };\n        this.setState({ loading: false, lastResponse: response, error });\n\n        if (!this.props.localErrorOnly && onError) {\n          onError(error, () => Promise.resolve(), response);\n        }\n      } else if (this.isModified(response, data)) {\n        this.setState(prevState => ({\n          loading: false,\n          lastResponse: response,\n          previousData: prevState.data,\n          data,\n          error: null,\n          lastPollIndex: response.headers.get(\"x-polling-index\") || undefined,\n        }));\n      }\n\n      // Wait for interval to pass.\n      await new Promise(resolvePromise => setTimeout(resolvePromise, interval));\n      this.cycle(); // Do it all again!\n    } catch (e) {\n      // the only error not catched is the `fetch`, this means that we have cancelled the fetch\n    }\n  };\n\n  public start = () => {\n    this.keepPolling = true;\n    if (!this.state.polling) {\n      this.setState(() => ({ polling: true })); // let everyone know we're done here.\n    }\n    this.cycle();\n  };\n\n  public stop = () => {\n    this.keepPolling = false;\n    this.setState(() => ({ polling: false, finished: true })); // let everyone know we're done here.\n  };\n\n  public componentDidMount() {\n    const { path, lazy } = this.props;\n\n    if (path === undefined) {\n      throw new Error(\n        `[restful-react]: You're trying to poll something without a path. Please specify a \"path\" prop on your Poll component.`,\n      );\n    }\n\n    if (!lazy) {\n      this.start();\n    }\n  }\n\n  public componentWillUnmount() {\n    // Cancel the current query\n    this.abortController.abort();\n\n    // Stop the polling cycle\n    this.stop();\n  }\n\n  public render() {\n    const { lastResponse: response, previousData, data, polling, loading, error, finished } = this.state;\n    const { children, base, path, resolve } = this.props;\n\n    const meta: Meta = {\n      response,\n      absolutePath: composeUrl(base!, \"\", path),\n    };\n\n    const states: States<TData, TError> = {\n      polling,\n      loading,\n      error,\n      finished,\n    };\n\n    const actions: Actions = {\n      stop: this.stop,\n      start: this.start,\n    };\n    // data is parsed only when poll has already resolved so response is defined\n    const resolvedData = response && resolve ? resolve(data, previousData) : data;\n    return children(resolvedData, states, actions, meta);\n  }\n}\n\nfunction Poll<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: PollProps<TData, TError, TQueryParams, TPathParams>,\n) {\n  // Compose Contexts to allow for URL nesting\n  return (\n    <RestfulReactConsumer>\n      {contextProps => {\n        const contextRequestOptions =\n          typeof contextProps.requestOptions === \"function\"\n            ? contextProps.requestOptions()\n            : contextProps.requestOptions || {};\n        const propsRequestOptions =\n          typeof props.requestOptions === \"function\" ? props.requestOptions() : props.requestOptions || {};\n\n        return (\n          <ContextlessPoll\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams }}\n            requestOptions={async () => merge(await contextRequestOptions, await propsRequestOptions)}\n          />\n        );\n      }}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Poll;\n","import * as qs from \"qs\";\nimport * as React from \"react\";\nimport RestfulReactProvider, { InjectedProps, RestfulReactConsumer, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { composePath, composeUrl } from \"./util/composeUrl\";\nimport { processResponse } from \"./util/processResponse\";\n\n/**\n * An enumeration of states that a fetchable\n * view could possibly have.\n */\nexport interface States<TData, TError> {\n  /** Is our view currently loading? */\n  loading: boolean;\n  /** Do we have an error in the view? */\n  error?: GetState<TData, TError>[\"error\"];\n}\n\nexport interface MutateRequestOptions<TQueryParams, TPathParams> extends RequestInit {\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Path parameters\n   */\n  pathParams?: TPathParams;\n}\n\nexport type MutateMethod<TData, TRequestBody, TQueryParams, TPathParams> = (\n  data: TRequestBody,\n  mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n) => Promise<TData>;\n\n/**\n * Meta information returned to the fetchable\n * view.\n */\nexport interface Meta {\n  /** The absolute path of this request. */\n  absolutePath: string;\n}\n\n/**\n * Props for the <Mutate /> component.\n */\nexport interface MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parents or the RestfulProvider.\n   */\n  path?: string;\n  /**\n   * @private This is an internal implementation detail in restful-react, not meant to be used externally.\n   * This helps restful-react correctly override `path`s when a new `base` property is provided.\n   */\n  __internal_hasExplicitBase?: boolean;\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * The accumulated path from each level of parent GETs\n   *  taking the absolute and relative nature of each path into consideration\n   */\n  parentPath?: string;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function that recieves a mutation function, along with\n   * some metadata.\n   *\n   * @param actions - a key/value map of HTTP verbs, aliasing destroy to DELETE.\n   */\n  children: (\n    mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>,\n    states: States<TData, TError>,\n    meta: Meta,\n  ) => React.ReactNode;\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n}\n\n/**\n * State for the <Mutate /> component. These\n * are implementation details and should be\n * hidden from any consumers.\n */\nexport interface MutateState<TData, TError> {\n  error: GetState<TData, TError>[\"error\"];\n  loading: boolean;\n}\n\n/**\n * The <Mutate /> component without Context. This\n * is a named class because it is useful in\n * debugging.\n */\nclass ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams> extends React.Component<\n  MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> & InjectedProps,\n  MutateState<TData, TError>\n> {\n  public readonly state: Readonly<MutateState<TData, TError>> = {\n    loading: false,\n    error: null,\n  };\n\n  public static defaultProps = {\n    base: \"\",\n    parentPath: \"\",\n    path: \"\",\n    queryParams: {},\n  };\n\n  /**\n   * Abort controller to cancel the current fetch query\n   */\n  private abortController = new AbortController();\n  private signal = this.abortController.signal;\n\n  public componentWillUnmount() {\n    this.abortController.abort();\n  }\n\n  public mutate = async (\n    body: TRequestBody,\n    mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>,\n  ) => {\n    const {\n      __internal_hasExplicitBase,\n      base,\n      parentPath,\n      path,\n      verb,\n      requestOptions: providerRequestOptions,\n      onError,\n      onRequest,\n      onResponse,\n    } = this.props;\n    this.setState(() => ({ error: null, loading: true }));\n\n    const makeRequestPath = () => {\n      let url: string;\n      if (__internal_hasExplicitBase) {\n        url =\n          verb === \"DELETE\" && typeof body === \"string\"\n            ? composeUrl(base!, \"\", composePath(path!, body))\n            : composeUrl(base!, \"\", path || \"\");\n      } else {\n        url =\n          verb === \"DELETE\" && typeof body === \"string\"\n            ? composeUrl(base!, parentPath!, composePath(path!, body))\n            : composeUrl(base!, parentPath!, path!);\n      }\n\n      // We use ! because it's in defaultProps\n      if (Object.keys(this.props.queryParams!).length) {\n        url += `?${qs.stringify({ ...this.props.queryParams, ...mutateRequestOptions?.queryParams })}`;\n      }\n      return url;\n    };\n\n    const request = new Request(makeRequestPath(), {\n      method: verb,\n      body: typeof body === \"object\" ? JSON.stringify(body) : body,\n      ...(typeof providerRequestOptions === \"function\" ? providerRequestOptions() : providerRequestOptions),\n      ...mutateRequestOptions,\n      headers: {\n        \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\",\n        ...(typeof providerRequestOptions === \"function\"\n          ? (await providerRequestOptions()).headers\n          : (providerRequestOptions || {}).headers),\n        ...(mutateRequestOptions ? mutateRequestOptions.headers : {}),\n      },\n    } as RequestInit); // Type assertion for version of TypeScript that can't yet discriminate.\n    if (onRequest) onRequest(request);\n\n    let response: Response;\n    try {\n      response = await fetch(request, { signal: this.signal });\n      if (onResponse) onResponse(response.clone());\n    } catch (e) {\n      const error = {\n        message: `Failed to fetch: ${e.message}`,\n        data: \"\",\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions));\n      }\n\n      throw error;\n    }\n\n    const { data, responseError } = await processResponse(response);\n\n    // avoid state updates when component has been unmounted\n    if (this.signal.aborted) {\n      return;\n    }\n    if (!response.ok || responseError) {\n      const error = {\n        data,\n        message: `Failed to fetch: ${response.status} ${response.statusText}`,\n        status: response.status,\n      };\n\n      this.setState({\n        error,\n        loading: false,\n      });\n\n      if (!this.props.localErrorOnly && onError) {\n        onError(error, () => this.mutate(body, mutateRequestOptions), response);\n      }\n\n      throw error;\n    }\n\n    this.setState({ loading: false });\n\n    if (this.props.onMutate) {\n      this.props.onMutate(body, data);\n    }\n\n    return data;\n  };\n\n  public render() {\n    const { children, path, base, parentPath } = this.props;\n    const { error, loading } = this.state;\n\n    return children(this.mutate, { loading, error }, { absolutePath: composeUrl(base!, parentPath!, path!) });\n  }\n}\n\n/**\n * The <Mutate /> component _with_ context.\n * Context is used to compose path props,\n * and to maintain the base property against\n * which all requests will be made.\n *\n * We compose Consumers immediately with providers\n * in order to provide new `parentPath` props that contain\n * a segment of the path, creating composable URLs.\n */\nfunction Mutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(props: MutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>) {\n  return (\n    <RestfulReactConsumer>\n      {contextProps => (\n        <RestfulReactProvider {...contextProps} parentPath={composePath(contextProps.parentPath, props.path!)}>\n          <ContextlessMutate<TData, TError, TQueryParams, TRequestBody, TPathParams>\n            {...contextProps}\n            {...props}\n            queryParams={{ ...contextProps.queryParams, ...props.queryParams } as TQueryParams}\n            __internal_hasExplicitBase={Boolean(props.base)}\n          />\n        </RestfulReactProvider>\n      )}\n    </RestfulReactConsumer>\n  );\n}\n\nexport default Mutate;\n","import isEqualWith from \"lodash/isEqualWith\";\nimport React, { useEffect, useRef } from \"react\";\n\n/**\n * Custom version of isEqual to handle function comparison\n */\nconst isEqual = (x: any, y: any) =>\n  isEqualWith(x, y, (a, b) => {\n    // Deal with the function comparison case\n    if (typeof a === \"function\" && typeof b === \"function\") {\n      return a.toString() === b.toString();\n    }\n    // Fallback on the method\n    return undefined;\n  });\n\nfunction useDeepCompareMemoize(value: Readonly<any>) {\n  const ref = useRef<any>();\n\n  if (!isEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\n/**\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * This is the deepCompare version of the `React.useEffect` hooks (that is shallowed compare)\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the values in the list change.\n *\n * @see https://gist.github.com/kentcdodds/fb8540a05c43faf636dd68647747b074#gistcomment-2830503\n */\nexport function useDeepCompareEffect<T>(effect: React.EffectCallback, deps: T) {\n  useEffect(effect, useDeepCompareMemoize(deps));\n}\n","import { useCallback, useRef } from \"react\";\n\nfunction createAbortController() {\n  try {\n    return new AbortController();\n  } catch {\n    return undefined;\n  }\n}\n\nexport function useAbort() {\n  const instance = useRef(createAbortController());\n\n  const abort = useCallback(() => {\n    if (instance && instance.current) {\n      instance.current.abort();\n      instance.current = createAbortController();\n    }\n  }, [instance]);\n\n  return {\n    abort,\n    getAbortSignal() {\n      return instance?.current?.signal;\n    },\n  };\n}\n","import { useCallback, useContext, useEffect, useState } from \"react\";\nimport { Cancelable, DebounceSettings } from \"lodash\";\nimport debounce from \"lodash/debounce\";\nimport merge from \"lodash/merge\";\nimport qs, { IStringifyOptions } from \"qs\";\nimport url from \"url\";\n\nimport { Context, RestfulReactProviderProps } from \"./Context\";\nimport { GetState } from \"./Get\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useDeepCompareEffect } from \"./util/useDeepCompareEffect\";\nimport { useAbort } from \"./useAbort\";\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport interface UseGetProps<TData, TError, TQueryParams, TPathParams> {\n  /**\n   * The path at which to request data,\n   * typically composed by parent Gets or the RestfulProvider.\n   */\n  path: string | ((pathParams: TPathParams) => string);\n  /**\n   * Path Parameters\n   */\n  pathParams?: TPathParams;\n  /** Options passed into the fetch call. */\n  requestOptions?: RestfulReactProviderProps[\"requestOptions\"];\n  /**\n   * Query parameters\n   */\n  queryParams?: TQueryParams;\n  /**\n   * Query parameter stringify options\n   */\n  queryParamStringifyOptions?: IStringifyOptions;\n  /**\n   * Don't send the error to the Provider\n   */\n  localErrorOnly?: boolean;\n  /**\n   * A function to resolve data return from the backend, most typically\n   * used when the backend response needs to be adapted in some way.\n   */\n  resolve?: (data: any) => TData;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: { data?: TData; error?: TError; loading?: boolean; response?: Response };\n  /**\n   * Should we fetch data at a later stage?\n   */\n  lazy?: boolean;\n  /**\n   * An escape hatch and an alternative to `path` when you'd like\n   * to fetch from an entirely different URL.\n   *\n   */\n  base?: string;\n  /**\n   * How long do we wait between subsequent requests?\n   * Uses [lodash's debounce](https://lodash.com/docs/4.17.10#debounce) under the hood.\n   */\n  debounce?:\n    | {\n        wait?: number;\n        options: DebounceSettings;\n      }\n    | boolean\n    | number;\n}\n\nexport function resolvePath<TQueryParams>(\n  base: string,\n  path: string,\n  queryParams: TQueryParams,\n  queryParamOptions: IStringifyOptions = {},\n) {\n  const appendedBase = base.endsWith(\"/\") ? base : `${base}/`;\n  const trimmedPath = path.startsWith(\"/\") ? path.slice(1) : path;\n\n  return url.resolve(\n    appendedBase,\n    Object.keys(queryParams).length ? `${trimmedPath}?${qs.stringify(queryParams, queryParamOptions)}` : trimmedPath,\n  );\n}\n\nasync function _fetchData<TData, TError, TQueryParams, TPathParams>(\n  props: UseGetProps<TData, TError, TQueryParams, TPathParams>,\n  state: GetState<TData, TError>,\n  setState: (newState: GetState<TData, TError>) => void,\n  context: RestfulReactProviderProps,\n  abort: () => void,\n  getAbortSignal: () => AbortSignal | undefined,\n) {\n  const {\n    base = context.base,\n    path,\n    resolve = (d: any) => d as TData,\n    queryParams = {},\n    queryParamStringifyOptions = {},\n    requestOptions,\n    pathParams = {},\n  } = props;\n\n  if (state.loading) {\n    // Abort previous requests\n    abort();\n  }\n\n  if (state.error || !state.loading) {\n    setState({ ...state, error: null, loading: true });\n  }\n\n  const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n  const propsRequestOptions = (typeof requestOptions === \"function\" ? await requestOptions() : requestOptions) || {};\n\n  const contextRequestOptions =\n    (typeof context.requestOptions === \"function\" ? await context.requestOptions() : context.requestOptions) || {};\n\n  const signal = getAbortSignal();\n\n  const request = new Request(\n    resolvePath(\n      base,\n      pathStr,\n      { ...context.queryParams, ...queryParams },\n      { ...context.queryParamStringifyOptions, ...queryParamStringifyOptions },\n    ),\n    merge({}, contextRequestOptions, propsRequestOptions, { signal }),\n  );\n  if (context.onRequest) context.onRequest(request);\n\n  try {\n    const response = await fetch(request);\n    if (context.onResponse) context.onResponse(response.clone());\n    const { data, responseError } = await processResponse(response);\n\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    if (!response.ok || responseError) {\n      const error = {\n        message: `Failed to fetch: ${response.status} ${response.statusText}${responseError ? \" - \" + data : \"\"}`,\n        data,\n        status: response.status,\n      };\n\n      setState({ ...state, loading: false, error });\n\n      if (!props.localErrorOnly && context.onError) {\n        context.onError(error, () => _fetchData(props, state, setState, context, abort, getAbortSignal), response);\n      }\n      return;\n    }\n\n    setState({ ...state, error: null, loading: false, data: resolve(data) });\n  } catch (e) {\n    // avoid state updates when component has been unmounted\n    // and when fetch/processResponse threw an error\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const error = {\n      message: `Failed to fetch: ${e.message}`,\n      data: e.message,\n    };\n\n    setState({\n      ...state,\n      loading: false,\n      error,\n    });\n\n    if (!props.localErrorOnly && context.onError) {\n      context.onError(error, () => _fetchData(props, state, setState, context, abort, getAbortSignal));\n    }\n  }\n}\n\ntype FetchData = typeof _fetchData;\ntype CancellableFetchData = FetchData | (FetchData & Cancelable);\ntype RefetchOptions<TData, TError, TQueryParams, TPathParams> = Partial<\n  Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\">\n>;\n\nconst isCancellable = <T extends (...args: any[]) => any>(func: T): func is T & Cancelable => {\n  return typeof (func as any).cancel === \"function\" && typeof (func as any).flush === \"function\";\n};\n\nexport interface UseGetReturn<TData, TError, TQueryParams = {}, TPathParams = unknown> extends GetState<TData, TError> {\n  /**\n   * Absolute path resolved from `base` and `path` (context & local)\n   */\n  absolutePath: string;\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Refetch\n   */\n  refetch: (options?: RefetchOptions<TData, TError, TQueryParams, TPathParams>) => Promise<void>;\n}\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  path: UseGetProps<TData, TError, TQueryParams, TPathParams>[\"path\"],\n  props?: Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"path\">,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>(\n  props: UseGetProps<TData, TError, TQueryParams, TPathParams>,\n): UseGetReturn<TData, TError, TQueryParams>;\n\nexport function useGet<TData = any, TError = any, TQueryParams = { [key: string]: any }, TPathParams = unknown>() {\n  const props: UseGetProps<TData, TError, TQueryParams, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[1], path: arguments[0] };\n\n  const context = useContext(Context);\n  const { path, pathParams = {} } = props;\n\n  const fetchData = useCallback<CancellableFetchData>(\n    typeof props.debounce === \"object\"\n      ? debounce<FetchData>(_fetchData, props.debounce.wait, props.debounce.options)\n      : typeof props.debounce === \"number\"\n      ? debounce<FetchData>(_fetchData, props.debounce)\n      : props.debounce\n      ? debounce<FetchData>(_fetchData)\n      : _fetchData,\n    [props.debounce],\n  );\n\n  // Cancel fetchData on unmount (if debounce)\n  useEffect(() => (isCancellable(fetchData) ? () => fetchData.cancel() : undefined), [fetchData]);\n\n  const [state, setState] = useState<GetState<TData, TError>>({\n    data: null,\n    response: null,\n    loading: !props.lazy,\n    error: null,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  const pathStr = typeof path === \"function\" ? path(pathParams as TPathParams) : path;\n\n  useDeepCompareEffect(() => {\n    if (!props.lazy && !props.mock) {\n      fetchData(props, state, setState, context, abort, getAbortSignal);\n    }\n\n    return () => {\n      abort();\n    };\n  }, [\n    props.lazy,\n    props.mock,\n    props.path,\n    props.base,\n    props.resolve,\n    props.queryParams,\n    props.requestOptions,\n    props.pathParams,\n    context.base,\n    context.parentPath,\n    context.queryParams,\n    context.requestOptions,\n    abort,\n  ]);\n\n  return {\n    ...state,\n    ...props.mock, // override the state\n    absolutePath: resolvePath(\n      props.base || context.base,\n      pathStr,\n      {\n        ...context.queryParams,\n        ...props.queryParams,\n      },\n      {\n        ...context.queryParamStringifyOptions,\n        ...props.queryParamStringifyOptions,\n      },\n    ),\n    cancel: () => {\n      setState({\n        ...state,\n        loading: false,\n      });\n      abort();\n    },\n    refetch: (options: RefetchOptions<TData, TError, TQueryParams, TPathParams> = {}) =>\n      fetchData({ ...props, ...options }, state, setState, context, abort, getAbortSignal),\n  };\n}\n","import merge from \"lodash/merge\";\nimport { useCallback, useContext, useEffect, useState } from \"react\";\nimport { Context } from \"./Context\";\nimport { MutateMethod, MutateState, MutateRequestOptions } from \"./Mutate\";\nimport { Omit, resolvePath, UseGetProps } from \"./useGet\";\nimport { processResponse } from \"./util/processResponse\";\nimport { useAbort } from \"./useAbort\";\n\nexport interface UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>\n  extends Omit<UseGetProps<TData, TError, TQueryParams, TPathParams>, \"lazy\" | \"debounce\" | \"mock\"> {\n  /**\n   * What HTTP verb are we using?\n   */\n  verb: \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\n  /**\n   * Callback called after the mutation is done.\n   *\n   * @param body - Body given to mutate\n   * @param data - Response data\n   */\n  onMutate?: (body: TRequestBody, data: TData) => void;\n  /**\n   * Developer mode\n   * Override the state with some mocks values and avoid to fetch\n   */\n  mock?: {\n    mutate?: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n    loading?: boolean;\n  };\n}\n\nexport interface UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>\n  extends MutateState<TData, TError> {\n  /**\n   * Cancel the current fetch\n   */\n  cancel: () => void;\n  /**\n   * Call the mutate endpoint\n   */\n  mutate: MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>;\n}\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(\n  verb: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"verb\"],\n  path: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>[\"path\"],\n  props?: Omit<UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams>, \"path\" | \"verb\">,\n): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams>;\n\nexport function useMutate<\n  TData = any,\n  TError = any,\n  TQueryParams = { [key: string]: any },\n  TRequestBody = any,\n  TPathParams = unknown\n>(): UseMutateReturn<TData, TError, TRequestBody, TQueryParams, TPathParams> {\n  const props: UseMutateProps<TData, TError, TQueryParams, TRequestBody, TPathParams> =\n    typeof arguments[0] === \"object\" ? arguments[0] : { ...arguments[2], path: arguments[1], verb: arguments[0] };\n\n  const context = useContext(Context);\n  const { verb, base = context.base, path, queryParams = {}, resolve, pathParams = {} } = props;\n  const isDelete = verb === \"DELETE\";\n\n  const [state, setState] = useState<MutateState<TData, TError>>({\n    error: null,\n    loading: false,\n  });\n\n  const { abort, getAbortSignal } = useAbort();\n\n  // Cancel the fetch on unmount\n  useEffect(() => () => abort(), [abort]);\n\n  const mutate = useCallback<MutateMethod<TData, TRequestBody, TQueryParams, TPathParams>>(\n    async (body: TRequestBody, mutateRequestOptions?: MutateRequestOptions<TQueryParams, TPathParams>) => {\n      if (state.error || !state.loading) {\n        setState(prevState => ({ ...prevState, loading: true, error: null }));\n      }\n\n      if (state.loading) {\n        // Abort previous requests\n        abort();\n      }\n\n      const pathStr =\n        typeof path === \"function\" ? path(mutateRequestOptions?.pathParams || (pathParams as TPathParams)) : path;\n\n      const pathParts = [pathStr];\n\n      const propsRequestOptions =\n        (typeof props.requestOptions === \"function\" ? await props.requestOptions() : props.requestOptions) || {};\n\n      const contextRequestOptions =\n        (typeof context.requestOptions === \"function\" ? await context.requestOptions() : context.requestOptions) || {};\n\n      const options: RequestInit = {\n        method: verb,\n      };\n\n      // don't set content-type when body is of type FormData\n      if (!(body instanceof FormData)) {\n        options.headers = { \"content-type\": typeof body === \"object\" ? \"application/json\" : \"text/plain\" };\n      }\n\n      if (body instanceof FormData) {\n        options.body = body;\n      } else if (typeof body === \"object\") {\n        options.body = JSON.stringify(body);\n      } else if (isDelete) {\n        pathParts.push((body as unknown) as string);\n      } else {\n        options.body = (body as unknown) as string;\n      }\n\n      const signal = getAbortSignal();\n\n      const request = new Request(\n        resolvePath(\n          base,\n          pathParts.join(\"/\"),\n          { ...context.queryParams, ...queryParams, ...mutateRequestOptions?.queryParams },\n          { ...context.queryParamStringifyOptions, ...props.queryParamStringifyOptions },\n        ),\n        merge({}, contextRequestOptions, options, propsRequestOptions, mutateRequestOptions, { signal }),\n      );\n      if (context.onRequest) context.onRequest(request);\n\n      let response: Response;\n      try {\n        response = await fetch(request);\n        if (context.onResponse) context.onResponse(response.clone());\n      } catch (e) {\n        const error = {\n          message: `Failed to fetch: ${e.message}`,\n          data: \"\",\n        };\n\n        setState({\n          error,\n          loading: false,\n        });\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body, mutateRequestOptions));\n        }\n\n        throw error;\n      }\n\n      const { data: rawData, responseError } = await processResponse(response);\n\n      let data: TData | any; // `any` -> data in error case\n      try {\n        data = resolve ? resolve(rawData) : rawData;\n      } catch (e) {\n        // avoid state updates when component has been unmounted\n        // and when fetch/processResponse threw an error\n        if (signal && signal.aborted) {\n          return;\n        }\n\n        const error = {\n          data: e.message,\n          message: `Failed to resolve: ${e.message}`,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n        throw e;\n      }\n\n      if (signal && signal.aborted) {\n        return;\n      }\n\n      if (!response.ok || responseError) {\n        const error = {\n          data,\n          message: `Failed to fetch: ${response.status} ${response.statusText}`,\n          status: response.status,\n        };\n\n        setState(prevState => ({\n          ...prevState,\n          error,\n          loading: false,\n        }));\n\n        if (!props.localErrorOnly && context.onError) {\n          context.onError(error, () => mutate(body), response);\n        }\n\n        throw error;\n      }\n\n      setState(prevState => ({ ...prevState, loading: false }));\n\n      if (props.onMutate) {\n        props.onMutate(body, data);\n      }\n\n      return data;\n    },\n    /* eslint-disable react-hooks/exhaustive-deps */\n    [context.base, context.requestOptions, context.resolve, state.error, state.loading, path, abort, getAbortSignal],\n  );\n\n  return {\n    ...state,\n    mutate,\n    ...props.mock,\n    cancel: () => {\n      setState(prevState => ({\n        ...prevState,\n        loading: false,\n      }));\n      abort();\n    },\n  };\n}\n"],"names":["_catch","body","recover","result","e","then","Symbol","iterator","asyncIterator","Context","React","base","parentPath","resolve","data","requestOptions","onError","noop","onRequest","onResponse","queryParams","queryParamStringifyOptions","RestfulReactProvider","render","this","props","children","value","Provider","RestfulReactConsumer","Consumer","composeUrl","path","composedPath","composePath","startsWith","endsWith","slice","length","url","processResponse","response","status","undefined","responseError","headers","get","includes","json","message","text","ContextlessGet","AbortController","_this","abortController","signal","loading","lazy","error","extraOptions","extraHeaders","Headers","options","requestPath","thisRequestOptions","__internal_hasExplicitBase","state","setState","getRequestOptions","request","Request","Object","keys","qs","makeRequestPath","fetch","clone","aborted","ok","statusText","localErrorOnly","resolvedData","resolveError","resolvedDataOrPromise","err","JSON","stringify","resolveData","resolved","debounce","wait","componentDidMount","componentDidUpdate","prevProps","isEqual","toString","componentWillUnmount","abort","refetch","absolutePath","Get","contextProps","Boolean","unresolvedData","ContextlessPoll","previousData","lastResponse","polling","finished","nextData","equal","interval","lastPollIndex","Prefer","keepPolling","isResponseOk","Promise","isModified","prevState","resolvePromise","setTimeout","cycle","until","stop","Error","start","meta","states","actions","ContextlessMutate","mutateRequestOptions","mutate","onMutate","method","verb","providerRequestOptions","_providerRequestOptio","useDeepCompareEffect","effect","deps","ref","useEffect","useRef","isEqualWith","current","a","b","createAbortController","useAbort","instance","useCallback","getAbortSignal","_instance$current","_fetchData","context","propsRequestOptions","contextRequestOptions","resolvePath","pathStr","merge","d","pathParams","queryParamOptions","appendedBase","trimmedPath","isCancellable","func","cancel","flush","arguments","useContext","fetchData","useState","mock","isDelete","rawData","FormData","pathParts","push","join"],"mappings":"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"}